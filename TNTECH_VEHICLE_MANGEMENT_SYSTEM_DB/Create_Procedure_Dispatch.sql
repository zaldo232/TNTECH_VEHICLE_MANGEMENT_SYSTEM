USE TNTECH_VEHICLE_MANGEMENT_SYSTEM
GO

CREATE OR ALTER PROCEDURE SP_GET_DISPATCH_AVAILABILITY
    @SEARCH_MONTH NVARCHAR(7) -- '2026-02'
AS
BEGIN
    SET NOCOUNT ON;

    -- 해당 월의 모든 날짜 생성
    DECLARE @StartDate DATE = CAST(@SEARCH_MONTH + '-01' AS DATE);
    DECLARE @EndDate DATE = EOMONTH(@StartDate);

    WITH AllDates AS (
        SELECT @StartDate AS DateVal
        UNION ALL
        SELECT DATEADD(DAY, 1, DateVal) FROM AllDates WHERE DateVal < @EndDate
    )
    SELECT DateVal INTO #Calendar FROM AllDates OPTION (MAXRECURSION 31);

    -- 가동 가능한 모델별 총 대수 (AVAILABLE 상태만)
    SELECT 
        VEHICLE_NAME,
        COUNT(*) AS TOTAL_COUNT
    INTO #TOTAL_VEHICLES
    FROM TB_VEHICLES
    WHERE VEHICLES_STATUS = 'AVAILABLE'
    GROUP BY VEHICLE_NAME;

    -- 날짜별/모델별 예약 건수 계산 (AM, PM, ALL 코드 기준)
    SELECT 
        CONVERT(NVARCHAR(10), RENTAL_DATE, 120) AS RENTAL_DATE,
        V.VEHICLE_NAME,
        -- ALL(종일)은 오전/오후 모두 점유한 것으로 계산
        SUM(CASE WHEN RENTAL_PERIOD IN ('ALL', 'AM') THEN 1 ELSE 0 END) AS AM_USED,
        SUM(CASE WHEN RENTAL_PERIOD IN ('ALL', 'PM') THEN 1 ELSE 0 END) AS PM_USED
    INTO #USED_COUNTS
    FROM TB_DISPATCH D
    JOIN TB_VEHICLES V ON D.LICENSE_PLATE = V.LICENSE_PLATE
    WHERE CONVERT(NVARCHAR(7), RENTAL_DATE, 120) = @SEARCH_MONTH
      AND D.DISPATCH_STATUS = 'RESERVED' -- 취소되지 않은 예약만
    GROUP BY CONVERT(NVARCHAR(10), RENTAL_DATE, 120), V.VEHICLE_NAME;

    -- 최종 결과 반환
    SELECT 
        C.RENTAL_DATE,
        T.VEHICLE_NAME,
        T.TOTAL_COUNT,
        (T.TOTAL_COUNT - ISNULL(U.AM_USED, 0)) AS AM_AVAILABLE,
        (T.TOTAL_COUNT - ISNULL(U.PM_USED, 0)) AS PM_AVAILABLE
    FROM (SELECT CONVERT(NVARCHAR(10), DateVal, 120) AS RENTAL_DATE FROM #Calendar) C
    CROSS JOIN #TOTAL_VEHICLES T
    LEFT JOIN #USED_COUNTS U ON C.RENTAL_DATE = U.RENTAL_DATE AND T.VEHICLE_NAME = U.VEHICLE_NAME
    WHERE (T.TOTAL_COUNT - ISNULL(U.AM_USED, 0)) > 0 OR (T.TOTAL_COUNT - ISNULL(U.PM_USED, 0)) > 0
    ORDER BY C.RENTAL_DATE, T.VEHICLE_NAME;

    DROP TABLE #Calendar;
    DROP TABLE #TOTAL_VEHICLES;
    DROP TABLE #USED_COUNTS;
END
GO

CREATE OR ALTER PROCEDURE SP_REGISTER_DISPATCH_REQUEST
    @MEMBER_ID      NVARCHAR(50),
    @LICENSE_PLATE  NVARCHAR(30),
    @RENTAL_DATE    DATETIME,
    @RENTAL_PERIOD  NVARCHAR(20),     -- AM, PM, ALL
    @REGION         NVARCHAR(100),
    @VISIT_PLACE    NVARCHAR(100),
    @BUSINESS_TYPE  NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE @TODAY NVARCHAR(8) = CONVERT(NVARCHAR(8), GETDATE(), 112);
    DECLARE @DISPATCH_ID NVARCHAR(50);
    DECLARE @HISTORY_ID NVARCHAR(50);
    DECLARE @MEMBER_NAME NVARCHAR(50);
    DECLARE @MEMBER_ROLE NVARCHAR(50);
    DECLARE @VEHICLE_NAME NVARCHAR(50);
    DECLARE @SERIAL_DISPATCH INT;
    DECLARE @SERIAL_HISTORY INT;

    BEGIN TRY
        -- [추가] 중복 예약 체크 로직
        IF EXISTS (
            SELECT 1 FROM TB_DISPATCH 
            WHERE LICENSE_PLATE = @LICENSE_PLATE 
              AND CONVERT(DATE, RENTAL_DATE) = CONVERT(DATE, @RENTAL_DATE)
              AND DISPATCH_STATUS = 'RESERVED'
              AND (RENTAL_PERIOD = 'ALL' OR @RENTAL_PERIOD = 'ALL' OR RENTAL_PERIOD = @RENTAL_PERIOD)
        )
        BEGIN
            RAISERROR(N'선택하신 차량은 해당 시간에 이미 예약되어 있습니다.', 16, 1);
            RETURN;
        END

        BEGIN TRANSACTION;

        -- 정보 조회
        SELECT @MEMBER_NAME = MEMBER_NAME, @MEMBER_ROLE = MEMBER_ROLE FROM TB_MEMBERS WHERE MEMBER_ID = @MEMBER_ID;
        SELECT @VEHICLE_NAME = VEHICLE_NAME FROM TB_VEHICLES WHERE LICENSE_PLATE = @LICENSE_PLATE;

        -- 채번 (DISPATCH)
        IF NOT EXISTS (SELECT 1 FROM TB_LAST_SERIAL WHERE BASE_DATE = 'D000_' + @TODAY AND SERIAL_TYPE = 'DISPATCH')
            INSERT INTO TB_LAST_SERIAL (BASE_DATE, SERIAL_TYPE, LAST_SERIAL) VALUES ('D000_' + @TODAY, 'DISPATCH', 0);
        UPDATE TB_LAST_SERIAL SET @SERIAL_DISPATCH = LAST_SERIAL = LAST_SERIAL + 1 WHERE BASE_DATE = 'D000_' + @TODAY AND SERIAL_TYPE = 'DISPATCH';
        SET @DISPATCH_ID = 'D' + RIGHT('000' + CAST(@SERIAL_DISPATCH AS NVARCHAR), 3) + '_' + @TODAY;

        -- 채번 (HISTORY)
        IF NOT EXISTS (SELECT 1 FROM TB_LAST_SERIAL WHERE BASE_DATE = 'H000_' + @TODAY AND SERIAL_TYPE = 'HISTORY')
            INSERT INTO TB_LAST_SERIAL (BASE_DATE, SERIAL_TYPE, LAST_SERIAL) VALUES ('H000_' + @TODAY, 'HISTORY', 0);
        UPDATE TB_LAST_SERIAL SET @SERIAL_HISTORY = LAST_SERIAL = LAST_SERIAL + 1 WHERE BASE_DATE = 'H000_' + @TODAY AND SERIAL_TYPE = 'HISTORY';
        SET @HISTORY_ID = 'H' + RIGHT('000' + CAST(@SERIAL_HISTORY AS NVARCHAR), 3) + '_' + @TODAY;

        -- 배차 등록
        INSERT INTO TB_DISPATCH (DISPATCH_ID, MEMBER_ID, LICENSE_PLATE, DISPATCH_STATUS, RENTAL_DATE, RENTAL_PERIOD, REGION, VISIT_PLACE, BUSINESS_TYPE)
        VALUES (@DISPATCH_ID, @MEMBER_ID, @LICENSE_PLATE, 'RESERVED', @RENTAL_DATE, @RENTAL_PERIOD, @REGION, @VISIT_PLACE, @BUSINESS_TYPE);

        -- 히스토리 등록
        INSERT INTO TB_HISTORY (RENTAL_HISTORY_ID, DISPATCH_ID, VEHICLE_NAME, MEMBER_ID, MEMBER_NAME, ACTION_TYPE, NOWROLE, RENTAL_DATE, REGION, VISIT_PLACE, BUSINESS_TYPE)
        VALUES (@HISTORY_ID, @DISPATCH_ID, @VEHICLE_NAME, @MEMBER_ID, @MEMBER_NAME, N'신청', @MEMBER_ROLE, @RENTAL_DATE, @REGION, @VISIT_PLACE, @BUSINESS_TYPE);

        COMMIT TRANSACTION;
        SELECT @DISPATCH_ID AS DISPATCH_ID;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

CREATE OR ALTER PROCEDURE SP_PROCESS_VEHICLE_RETURN
    @DISPATCH_ID        NVARCHAR(50),   -- 대상 배차 ID
    @RETURN_DATE        DATETIME,       -- 실제 반납 일시
    @START_MILEAGE      INT,            -- 출발 시 주행거리
    @END_MILEAGE        INT,            -- 도착 시 주행거리
    @COMMUTE_DISTANCE   INT             -- 출퇴근 거리
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE @TODAY NVARCHAR(8) = CONVERT(NVARCHAR(8), GETDATE(), 112);
    DECLARE @HISTORY_ID NVARCHAR(50);
    DECLARE @SERIAL_HISTORY INT;
    
    DECLARE @MEMBER_ID NVARCHAR(50), @MEMBER_NAME NVARCHAR(50), @MEMBER_ROLE NVARCHAR(50);
    DECLARE @LICENSE_PLATE NVARCHAR(30), @VEHICLE_NAME NVARCHAR(50);

    BEGIN TRY
        BEGIN TRANSACTION;

        -- 1. 기존 정보 조회 (히스토리 기록용)
        SELECT @MEMBER_ID = MEMBER_ID, @LICENSE_PLATE = LICENSE_PLATE 
        FROM TB_DISPATCH WHERE DISPATCH_ID = @DISPATCH_ID;

        SELECT @MEMBER_NAME = MEMBER_NAME, @MEMBER_ROLE = MEMBER_ROLE FROM TB_MEMBERS WHERE MEMBER_ID = @MEMBER_ID;
        SELECT @VEHICLE_NAME = VEHICLE_NAME FROM TB_VEHICLES WHERE LICENSE_PLATE = @LICENSE_PLATE;

        -- 2. 이력 ID 채번 (H000_YYYYMMDD)
        IF NOT EXISTS (SELECT 1 FROM TB_LAST_SERIAL WHERE BASE_DATE = 'H000_' + @TODAY AND SERIAL_TYPE = 'HISTORY')
            INSERT INTO TB_LAST_SERIAL (BASE_DATE, SERIAL_TYPE, LAST_SERIAL) VALUES ('H000_' + @TODAY, 'HISTORY', 0);

        UPDATE TB_LAST_SERIAL SET @SERIAL_HISTORY = LAST_SERIAL = LAST_SERIAL + 1 
        WHERE BASE_DATE = 'H000_' + @TODAY AND SERIAL_TYPE = 'HISTORY';

        SET @HISTORY_ID = 'H' + RIGHT('000' + CAST(@SERIAL_HISTORY AS NVARCHAR), 3) + '_' + @TODAY;

        -- 3. 메인 배차 테이블 업데이트 (상태: RETURNED)
        UPDATE TB_DISPATCH
        SET DISPATCH_STATUS = 'RETURNED',
            START_MILEAGE = @START_MILEAGE,
            END_MILEAGE = @END_MILEAGE,
            RETURN_DATE = @RETURN_DATE,
            COMMUTE_DISTANCE = @COMMUTE_DISTANCE
        WHERE DISPATCH_ID = @DISPATCH_ID;

        -- 4. 차량 마스터 주행거리 갱신
        UPDATE TB_VEHICLES
        SET MILEAGE = @END_MILEAGE,
            VEHICLES_STATUS = 'AVAILABLE' -- 다시 대여 가능 상태로 변경
        WHERE LICENSE_PLATE = @LICENSE_PLATE;

        -- 5. 이력 관리 테이블 INSERT (Action: 반납)
        -- 대여 관련 정보는 NULL 처리하고 반납 정보 위주로 입력
        INSERT INTO TB_HISTORY (
            RENTAL_HISTORY_ID, DISPATCH_ID, VEHICLE_NAME, MEMBER_ID, MEMBER_NAME, 
            ACTION_TYPE, NOWROLE, RETURN_DATE, END_MILEAGE, BUSINESS_DISTANCE,
            RENTAL_DATE, REGION, VISIT_PLACE, BUSINESS_TYPE -- 대여 정보는 NULL
        ) VALUES (
            @HISTORY_ID, @DISPATCH_ID, @VEHICLE_NAME, @MEMBER_ID, @MEMBER_NAME, 
            N'반납', @MEMBER_ROLE, @RETURN_DATE, @END_MILEAGE, (@END_MILEAGE - @START_MILEAGE - @COMMUTE_DISTANCE),
            NULL, NULL, NULL, NULL
        );

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

USE TNTECH_VEHICLE_MANGEMENT_SYSTEM
GO

CREATE OR ALTER PROCEDURE SP_GET_DISPATCH_STATUS
    @STATUS    NVARCHAR(20),
    @MEMBER_ID NVARCHAR(50) = NULL,
    @MONTH     NVARCHAR(7)  = NULL
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        D.DISPATCH_ID, 
        D.MEMBER_ID, 
        M.MEMBER_NAME,
        D.LICENSE_PLATE, 
        V.VEHICLE_NAME,
        D.RENTAL_DATE, 
        D.RENTAL_PERIOD, 
        D.REGION, 
        D.VISIT_PLACE, 
        D.BUSINESS_TYPE,
        D.START_MILEAGE, 
        V.MILEAGE AS VEHICLE_MILEAGE,
        D.DISPATCH_STATUS -- [핵심 추가] 프론트에서 확실히 거를 수 있게 상태값을 넘겨줌
    FROM TB_DISPATCH D
    JOIN TB_MEMBERS M ON D.MEMBER_ID = M.MEMBER_ID
    JOIN TB_VEHICLES V ON D.LICENSE_PLATE = V.LICENSE_PLATE
    
    -- [절대 방어] 백엔드에서 뭘 보내든 무시하고, 오직 '대여 중(RESERVED)'인 것만 달력에 노출되도록 강제 고정!
    WHERE D.DISPATCH_STATUS = 'RESERVED' 
      AND (@MONTH IS NULL OR CONVERT(NVARCHAR(7), D.RENTAL_DATE, 120) = @MONTH)
    ORDER BY D.RENTAL_DATE DESC;
END
GO

CREATE OR ALTER PROCEDURE SP_RETURN_VEHICLE_STACK
    @DISPATCH_ID      NVARCHAR(50), -- [핵심 추가] 어떤 배차건인지 정확히 짚어줌
    @MEMBER_ID        NVARCHAR(50), 
    @LICENSE_PLATE    NVARCHAR(30),
    @END_MILEAGE      INT,
    @RETURN_DATE      DATETIME,
    @VISIT_PLACE      NVARCHAR(100)
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE @TODAY NVARCHAR(8) = CONVERT(NVARCHAR(8), GETDATE(), 112);
    DECLARE @NEW_DISPATCH_ID NVARCHAR(50);
    DECLARE @SERIAL_DISPATCH INT;
    
    DECLARE @ORIG_MEMBER_ID   NVARCHAR(50); 
    DECLARE @ORIG_RENTAL_DATE DATETIME;
    DECLARE @ORIG_PERIOD      NVARCHAR(20);
    DECLARE @ORIG_REGION      NVARCHAR(100);
    DECLARE @ORIG_BIZ_TYPE    NVARCHAR(50);
    DECLARE @START_MILEAGE    INT;

    BEGIN TRY
        -- 1. [수정] 차 번호가 아니라 '고유 ID'로 정확히 그 예약만 가져옴
        SELECT TOP 1 
            @ORIG_MEMBER_ID   = MEMBER_ID,   
            @ORIG_RENTAL_DATE = RENTAL_DATE,
            @ORIG_PERIOD      = RENTAL_PERIOD,
            @ORIG_REGION      = REGION,
            @ORIG_BIZ_TYPE    = BUSINESS_TYPE,
            @START_MILEAGE    = (SELECT MILEAGE FROM TB_VEHICLES WHERE LICENSE_PLATE = @LICENSE_PLATE)
        FROM TB_DISPATCH
        WHERE DISPATCH_ID = @DISPATCH_ID; -- [수정] 타겟팅 완벽 고정

        BEGIN TRANSACTION;

        -- 2. [수정] 정확히 그 예약만 'COMPLETED' 처리
        UPDATE TB_DISPATCH SET DISPATCH_STATUS = 'COMPLETED' 
        WHERE DISPATCH_ID = @DISPATCH_ID;

        -- 3. 새 ID 채번
        IF NOT EXISTS (SELECT 1 FROM TB_LAST_SERIAL WHERE BASE_DATE = 'D000_' + @TODAY AND SERIAL_TYPE = 'DISPATCH')
            INSERT INTO TB_LAST_SERIAL (BASE_DATE, SERIAL_TYPE, LAST_SERIAL) VALUES ('D000_' + @TODAY, 'DISPATCH', 0);
        UPDATE TB_LAST_SERIAL SET @SERIAL_DISPATCH = LAST_SERIAL = LAST_SERIAL + 1 WHERE BASE_DATE = 'D000_' + @TODAY AND SERIAL_TYPE = 'DISPATCH';
        SET @NEW_DISPATCH_ID = 'D' + RIGHT('000' + CAST(@SERIAL_DISPATCH AS NVARCHAR), 3) + '_' + @TODAY;

        -- 4. 반납 줄 INSERT
        INSERT INTO TB_DISPATCH (
            DISPATCH_ID, MEMBER_ID, LICENSE_PLATE, DISPATCH_STATUS, 
            RENTAL_DATE, RENTAL_PERIOD, REGION, VISIT_PLACE, BUSINESS_TYPE, 
            START_MILEAGE, END_MILEAGE, RETURN_DATE 
        ) VALUES (
            @NEW_DISPATCH_ID, @ORIG_MEMBER_ID, @LICENSE_PLATE, 'RETURNED',
            @ORIG_RENTAL_DATE, @ORIG_PERIOD, @ORIG_REGION, @VISIT_PLACE, @ORIG_BIZ_TYPE,
            @START_MILEAGE, @END_MILEAGE, @RETURN_DATE
        );

        -- 5. 주행거리 갱신
        UPDATE TB_VEHICLES SET MILEAGE = @END_MILEAGE, VEHICLES_STATUS = 'AVAILABLE' WHERE LICENSE_PLATE = @LICENSE_PLATE;

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

CREATE OR ALTER PROCEDURE SP_GET_DASHBOARD_DISPATCH
    @TARGET_MONTH NVARCHAR(7)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        D.DISPATCH_ID,
        D.DISPATCH_STATUS,
        D.RENTAL_DATE,
        D.RENTAL_PERIOD,
        V.VEHICLE_NAME,
        D.LICENSE_PLATE, 
        D.REGION,        
        D.VISIT_PLACE,   
        ISNULL(C.CODE_NAME, D.BUSINESS_TYPE) AS BUSINESS_TYPE,
        ISNULL(M.MEMBER_NAME, D.MEMBER_ID) AS MEMBER_NAME
    FROM TB_DISPATCH D
    LEFT JOIN TB_VEHICLES V ON D.LICENSE_PLATE = V.LICENSE_PLATE
    LEFT JOIN TB_MEMBERS M ON D.MEMBER_ID = M.MEMBER_ID
    LEFT JOIN TB_COMMONCODE C ON D.BUSINESS_TYPE = C.CONTENT_CODE AND C.GROUP_CODE = '업무구분'
    WHERE D.DISPATCH_STATUS != 'CANCELED' 
      AND CONVERT(NVARCHAR(7), D.RENTAL_DATE, 120) = @TARGET_MONTH
    ORDER BY D.RENTAL_DATE ASC;
END
GO

CREATE OR ALTER PROCEDURE [dbo].[SP_CANCEL_DISPATCH]
    @DISPATCH_ID NVARCHAR(50),
    @MEMBER_ID NVARCHAR(50) -- 취소를 요청한 사용자 ID
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        -- 1. 데이터 존재 여부 및 현재 상태 확인
        DECLARE @CURRENT_STATUS NVARCHAR(20);
        
        SELECT @CURRENT_STATUS = DISPATCH_STATUS 
        FROM TB_DISPATCH 
        WHERE DISPATCH_ID = @DISPATCH_ID;

        IF @CURRENT_STATUS IS NULL
        BEGIN
            SELECT 0 AS [SUCCESS], '해당 배차 내역을 찾을 수 없습니다.' AS [MSG];
            RETURN;
        END

        IF @CURRENT_STATUS != 'RESERVED'
        BEGIN
            SELECT 0 AS [SUCCESS], '예약(RESERVED) 상태인 배차만 취소할 수 있습니다.' AS [MSG];
            RETURN;
        END

        BEGIN TRAN;

        -- 2. 배차 테이블 상태 변경 (RESERVED -> CANCELED)
        UPDATE TB_DISPATCH
        SET DISPATCH_STATUS = 'CANCELED'
        WHERE DISPATCH_ID = @DISPATCH_ID;

        -- 3. 이력 테이블(TB_HISTORY)에 취소 내역 기록
        DECLARE @HISTORY_ID NVARCHAR(50) = 'H' + FORMAT(GETDATE(), 'yyyyMMddHHmmss') + '_' + LEFT(REPLACE(NEWID(), '-', ''), 5);
        
        INSERT INTO TB_HISTORY (
            RENTAL_HISTORY_ID, DISPATCH_ID, MEMBER_ID, ACTION_TYPE, CREATED_AT
        )
        VALUES (
            @HISTORY_ID, @DISPATCH_ID, @MEMBER_ID, '취소', GETDATE()
        );

        COMMIT TRAN;
        SELECT 1 AS [SUCCESS], '배차 예약이 취소되었습니다.' AS [MSG];
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRAN;
        SELECT 0 AS [SUCCESS], ERROR_MESSAGE() AS [MSG];
    END CATCH
END
GO